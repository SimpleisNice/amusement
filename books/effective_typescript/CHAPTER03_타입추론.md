## 3장 - 타입 추론

TS는 타입 추론을 적극적으로 수행합니다.

타입 추론은 수동으로 명시해야 하는 타입 구문의 수를 엄청나게 줄여주기 때문에, 코드의 전체적인 안정성이 향상됨

3장에서는

- 타입 추론에서 발생할 수 있는 몇 가지 문제와 그 해법을 안내함
- 읽은 후에는 TS가 어떻게 타입을 추론하는지, 언제 타입 선언을 작성해야 하는지, 타입 추론이 가능하더라도 명시적으로 타입 선언을 작성하는 것이 필요한 상황은 언제인지 이해할 수 있게 됨

### 아이템19 - 추론 가능한 타입을 사용해 장환한 코드 방지하기

타입 추론이 된다면 명시적 타입 구문은 필요하지 않음, 오히려 방해가 됨

타입이 추론된다면 리팩터링 역시 용이해짐

정보가 부족해서 타입스크립트가 스스로 타입을 판단하기 어려운 상황에는 명시적으로 타입 구문이 필요

- TS는 최종 사용처까지 고려하지 않음
- TS에서 변수의 타입은 일반적으로 처음 등장할 때 결정됨

이상적인 타입스크립트 코드는 함수/메서드 시그니처에 타입 구문을 포함하지만, 함수 내에서 생성된 지역 변수에는 타입 구문을 넣지 않음

- 타입 구문을 생략하여 방해되는 것들을 최소화하고 코드를 읽는 사람이 구현 로직에 집중할 수 있게 하는 것이 좋음

반환 타입을 명시하면, 구현상의 오류가 사용자 코드의 오류로 표시되지 않으며, 다음의 장점이 있다.

- 오류의 위치를 제대로 표시
- 반환 타입을 명시하면 함수에 대해 더욱 명확하게 알 수 있음
- 명명된 타입을 사용하기 위해서

#### 추가적으로

- 비구조화 할당문은 모든 지역 변수의 타입이 추론되도록 함

### 아이템20 - 다른 타입에는 다른 변수 사용하기

다른 타입에는 별도의 변수를 사용하는 게 바람직한 이유?

- 서로 관련이 없는 두 개의 값을 분리
- 변수명을 더 구체적으로 지을 수 있음
- 타입 추론을 향상시키며, 타입 구문이 불필요해 짐
- 타입이 좀 더 간결해진다
- let 대신 const로 변수를 선언하게됨. const로 변수를 선언하면 코드가 간결해지고, 타입 체커가 타입을 추론하기에도 좋음

타입이 바뀌는 변수는 되도록 피해야 하며, 목적이 다른 곳에는 별도의 변수명을 사용해야 한다.

### 아이템21 - 타입 넓히기

TS가 작성된 코드를 체크하는 정적 분석 시점에, 변수는 "가능한" 값들의 집합인 타입을 가짐

상수를 사용해서 변수를 초기화할 때 타입을 명시하지 않으면 타입 체커는 타입을 결정해야 한다. 이 말은 지정된 타입 값을 가지고 할당 가능한 값들의 집합을 유추해야 한다는 뜻이며, TS에서는 이러한 과정을 "넓히기(widening)"이라고 부른다.

TS는 넓히기 과정을 제어할 수 있도록 몇 가지 방법을 제공합

- const

타입 추론의 강도를 직접 제어하려면 TS의 기본 동작을 제정의해야함

- TS의 기본 동작을 재정의하는 방법은?
  - 명시적 타입 구문을 제공
  - 타입 체커에 추가적인 문맥을 제공
  - const 단언문 사용

### 아이템22 - 타입 좁히기

TS가 넓은 타입으로부터 좁은 타입으로 진행하는 과정을 말함

타입을 좁히는 방법은?

```ts
const el = document.getElementById("foo");
if (!el) throw new Error("Unable to find #foo");
el.innerHTML = "party Time".blink();
```

```ts
function contains(text: string, search: string | RegExp) {
  // search 타입이 RegExp
  if (search instanceof RegExp) {
    return !!search.exec(text);
  }
  //  search 타입이 string
  return text.includes(search);
}
```

```ts
interface A {
  a: number;
}
interface B {
  b: number;
}
function pickAB(ab: A | B) {
  if ("a" in ab) {
    // 타입이 A
  } else if ("b" in ab) {
    // 타입이 B
  }
  return; // 타입이 A | B
}
```

```ts
interface UploadEvent {
  type: "upload";
  filename: string;
  contents: string;
}
interface DownloadEvent {
  type: "download";
  filename: string;
}

type AppEvent = UploadEvent | DownloadEvent;

function handleEvent(e: AppEvent) {
  switch (e.type) {
    case "download":
      // e 타입은 DownloadEvent
      break;
    case "upload":
      // e 타입은 uploadEvent
      break;
  }
}
```

### 아이템23 - 한꺼번에 객체 생성하기

객체를 생성할 때는 속성을 하나씩 추가하기보다는 여러 속성을 포함해서 한꺼번에 생성해야 타입 추론에 유리

- 안전한 타입으로 속성을 추가하려면 객체 전개 `({...a, ...b})`을 사용하면 됨

### 아이템24 - 일관성 있는 별칭 사용하기

별칭은 타입스크립트가 타입을 좁히는 것을 방해함, 따라서 변수에 별칭을 사용할 때는 일관되게 사용해야함

객체의 비구조화를 이용하면 보다 간결한 문법으로 일관된 이름을 사용할 수 있음
